This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories.

Alternatively, look at the find man page.

To access this level, log in as level00 with the password of level00.

1. find the program from the root directory

2. learn how to use the 'find' command

use 'find --help' for more info about find

find where-to-look criteria what-to-do
find  path  -option  [  -print ]  [ -exec  -ok  command ]  {} \
find / -executable -user flag00 2> /dev/null

where-to-look defaults to . (that is, the current working directory), criteria defaults to none (that is, select all files), and what-to-do (known as the find action) defaults to ‑print (that is, display the names of found files to standard output).  Technically, the criteria and actions are all known as find primaries.

example1:
find / -name foo
This will search the whole system for any files named foo and display their pathnames.  Here we are using the criterion ‑name with the argument foo to tell find to perform a name search for the filename foo.  The output might look like this:

	/home/wpollock/foo
	/home/ua02/foo
	/tmp/foo

find will display a error message for each directory on which you don't have read permission.  This can be a lot of messages, and the matching files that are found may scroll right off your screen.  A good way to deal with this problem is to redirect the error messages so you don't have to see them at all:

find / -name foo 2>/dev/null
You can specify as many places to search as you wish:(use space(' ') to seperate the path)

find /tmp /var/tmp . $HOME -name foo

ref:http://content.hccfl.edu/pollock/Unix/FindCmd.htm

You can use shell-style wildcards in the ‑name search argument:

find . -name foo\*bar(note the '\' here)
This will search from the current directory down for foo*bar (that is, any filename that begins with foo and ends with bar).  Note that wildcards in the name argument must be quoted so the shell doesn't expand them before passing them to find.  Also, unlike regular shell wildcards, these will match leading periods in filenames.  (For example “find ‑name \*.txt” would match “.foo.txt”.)

Here's an example using two search criteria:

find / -type f -mtime -7 | xargs tar -rf weekly_incremental.tar
the criterias seperated with space are combined with AND in default

&& AND
|| OR
| PIPELINE

ref: http://www.tecmint.com/chaining-operators-in-linux-with-practical-examples/

will find any regular files (i.e., not directories or other special files) with the criterion “‑type f”, and only those modified seven or fewer days ago (“‑mtime ‑7”).  Note the use of xargs, a handy utility that coverts a stream of input (in this case the output of find) into command line arguments for the supplied command (in this case tar, used to create a backup archive).

