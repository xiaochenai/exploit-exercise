srand: initialize random number generato

getenv:
char *getenv(const char *name);
searches the envionment list to find the environment variable name, and returns a pointoer to the corresponding value string.

getpid:
get the process identification

open man page:
http://linux.die.net/man/3/open
Upon successful completion, the function shall open the file and return a non-negative integer representing the lowest numbered unused file descriptor

unlink:
delete a name and possibly the file it refers to

key = length & 0xff; //truncate the key to 8 bits

strncmp:
<0	the first character that does not match has a lower value in str1 than in str2
0	the contents of both strings are equal
>0	the first character that does not match has a greater value in str1 than in str2

fgets:
char * fgets ( char * str, int num, FILE * stream );
Reads characters from stream and stores them as a C string into str until (num-1) characters have been read or either a newline or the end-of-file is reached, whichever happens first.

A newline character makes fgets stop reading, but it is considered a valid character by the function and included in the string copied to str.

A terminating null character is automatically appended after the characters copied to str.

atoi:
Parses the C-string str interpreting its content as an integral number, which is returned as a value of type int.


  if(fgets(line, sizeof(line), stdin) == NULL) {
      errx(1, "reading from stdin");
  }

  if(strncmp(line, CL, strlen(CL)) != 0) {
      errx(1, "invalid header");
  }
  //read in the length of command, the newline character is inclueded 

  Test case:
  	Content-Length: 8
  	123
  	123

  	Content-Length: 8
  	12
  	12
  	1
Content-Length: cmd
line is what user entered
length = cmd (if cmd is numeric otherwise is 0)
fread:
http://www.cplusplus.com/reference/cstdio/fread/
size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );
Reads an array of count elements, each one with a size of size bytes, from the stream and stores them in the block of memory specified by ptr.
THe return value:
	The total number of elements successfully read is returned
So the return value of the fread function in line 71 will always be 1

Line 71: fread(buf, length, 1, stdin)
read in characters and return 1

since the cmd length is limited if variable "length" is 1 so the codes inside first If statement may be useless.

a possible approach when Content-Length: 1
	1. stop program
	2. overwrite the memory for buf
because in process function, when length is 1 the for statement only executed once and key is 1.
	buffer[i] ^= key
	buffer[1] remains the same
	We can set buffer[1] as ";" and overwrite the following memory to /bin/getflag (this is known as buffer overflow)

ref: http://cybergibbons.com/security-2/nebula-walkthrough/nebula-exploit-exercises-walkthrough-level11/
pre-set memory use LD_PRELOAD
This technique uses an environment variable called LD_PRELOAD. This is commonly used to override library functions for debugging (or exploits!). When the linker starts up, it reads the entirity of LD_PRELOAD onto the stack and then doesn’t clean up afterwards. This means we can initialise the memory to something under out control:
export LD_PRELOAD=`python -c 'print "/bin/getflag\x0a"*1000'`




try 1024 for length
Content-Length: 1024
 blue = 1024
 go into getrand
	 tmp = getenv("TEMP")// we can use export TEMP="tmpVal" to set the value of tmp
	 ...
	 *path = tmpVal/pid.randNum
	 fd = open(*path....)//return a non-negative integer representing the lowest numbered unused file descriptor/-1
	 		file descriptor:
	 			0	Standard input	STDIN_FILENO	stdin
				1	Standard output	STDOUT_FILENO	stdout
				2	Standard error	STDERR_FILENO	stderr
 *buf = content from stdin
 pink = size of *buf
 write(fd,buf,pink)//write pink bytes from buf to file referred to by the file descriptor fd
 				   //fd refers to the file in *path
write:
ssize_t write(int fd, const void *buf, size_t count);
write() writes up to count bytes from the buffer pointed buf to the
       file referred to by the file descriptor fd.

 mem = mmap(.....)//this get the content in *path
 //at this point we know, mem is content from stdin
 process(mem,length)

In process function:
We want execute "getflag"
The last line should be system("getflag")

So we want something like this:
			 __________          ________
	cmd---> |          |------->|        |---->cmd
			|reverse   |internal|process |
			|__________|        |________|

we need to know the output of reverse or what the reverse is
process(mem,length)
length is at least 1024

char buf[1024];
pink = fread(buf, 1, sizeof(buf), stdin);
write(fd, buf, pink);
//buf, content in fd is 1024
mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);

If we have both processed key and buffer, then we can do:
	for i = length-1 to 0
		key = key + buffer[i]
		buffer[i] = buffer[i]^key
but we don't have the processed key.

we know the original key is length & 0xff, and we have the processed buffer[0]

so the original buffer[0] is (processed buffer[0])^(original key)
then the new key: key = key - (processed buffer[0])// we can either cached the processed buffer[0] or re-calc it

so the reverse should looks like this:

key = length & 0xff;
char tempBuffer;
for i = 0  to length-1:
	tempBuffer = buffer[i]
	buffer[i] = buffer[i]^key
	key = key - tempBuffer

//then we get the internal
//pass the internal as input of process it will produce the cmd.


look at level11-1 for the code of reverse.
		level11-2 for test result.

what we need to do now:
Because the length is at least 1024, so we can either enter by hand or pass the value by program.
1. enter by hand
	call reverse function with "getflag", 1024+strlen("getflag")//remember this value
	save the buf to a file
	start ./flag11
	Content-Length: the value of 1024+strlen("getflag")
	copy the content of file and paste it here

2. by program
	tried printf("Content-Length: 1031")
		.....
	this does not work
	http://stackoverflow.com/questions/2454474/what-is-the-difference-between-printf-and-puts-in-c
	use either printf("****\n") or puts("*****")
	the code is in level11-3
	/tmp/text | ./flag11
	this is tested in bt5r3 the result is in level11-4
Unfortunately, when moved to challenge env, the getflag is executing on a non-flag account

tried http://uberskill.blogspot.com/2012/09/nebula-level11.html
but getflag is still not executed on flag11

find sth here: http://cybergibbons.com/security-2/nebula-walkthrough/nebula-exploit-exercises-walkthrough-level11/

this is a bug – the call to system isn’t preceded by setresuid/setresgid, so anything it runs will run as the real UID (level11) instead of the effective UID (flag11).

6 h