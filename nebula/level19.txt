at a first glance, it looks we can use RE/DEBUG ways to set/overwrite the struct's memory then execute the bash. This looks complex and is out of my current tech stack.

struct stat: http://linux.die.net/man/2/stat
another possible vulnerable point will be  snprintf(buf, sizeof(buf)-1, "/proc/%d", getppid())
go to /proc folder and there are three directories related to level19
 14131
 14145
 14366

probably we can do something at this point.
There is no write permission for us in all of those three folders

parent process
     |
     |
     |------>current process: If parent process's uid is 0 then execute bash
     										|
     										|
     										|----->this is saved in /proc/pid/stat which we don't have write permission

we still need to change the parent process's uid to 0 to execute bash 

google "how to change parrent process"

ref: http://stackoverflow.com/questions/3842235/changing-a-processs-parent
Found this "sometimes the parent process is killed before its child is killed. In this case, the "parent of all processes," init process, becomes the new PPID (parent process ID). Sometime these processes are called orphan process."

use "ps aux" to print out the user ID associated with a process.
The init process's PID is 1 and the user of PID-1 is root.
The UID of root user is 0
execve: http://linux.die.net/man/2/execve
execl: http://linux.die.net/man/3/execl
program ref: http://www.kroosec.com/2012/11/nebula-level19.html

This is a program written for testing execve("/home/flag19/flag19",argvs,NULL); purpose

main(int argc, char *argv[]){
	printf("params: %s\n%s",argv[0],argv[1]);
	char *argvs[] = {"/bin/sh","-c","getflag > /tmp/output",NULL};
	/*
	*argvs[] = {"-c","getflag > /tmp/output",NULL}; 
	*argvs[] = {"/bin/sh","-c","getflag > /tmp/output",NULL};
	*argvs[] = {"/bin/sh","getflag > /tmp/output",NULL};


	*/
	execve("/bin/sh",argvs,NULL);
}


in the shell test:
/bin/sh ls
/bin/sh -c ls
/bin/sh "getflag > /tmp/output" //compare this with *argvs[] = {"/bin/sh","getflag > /tmp/output",NULL};
/bin/sh, then   /bin/sh ls
				ls
				/bin/sh -c ls

think about these cases:
execve("/bin/sh",argvs,NULL);//and the different cases of argvs
/bin/sh ls
/bin/sh -c ls


Why they are different?