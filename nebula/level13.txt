In order to pass this challenge we need to fake our uid to 1000
http://www.linuxquestions.org/questions/programming-9/faking-uids-917910/
#include <stdio.h>

int main()
{
    int uid;

    __asm__ ("mov $24, %%eax;"
        "int $0x80;" //System calls in Linux are done through int 0x80.
        "movl %%eax, %0;"
        : "=r"(uid));
             
    printf("uid: %i\n", uid);
    return 0;
}

24. sys_getuid

Syntax: int sys_getuid(void)

Source: kernel/sys.c

Action: get user identity
This approach has not been got done yet.

http://mips42.altervista.org/ld_preload.php
http://www.kroosec.com/2011/10/library-preloading-for-reverse.html
create libfake.c libfake.so target.c target in /tmp
LD_PRELOAD=./libfake.so ./target works, the uid is 1000
LD_PRELOAD=./libfake.so /home/flag13/flag13 does not work
cp ./libfake.so /home/flag13/   permission denied
cp /home/flag13/flag13 ./       flag13 is copied to /tmp
LD_PRELOAD=./libfake.so ./flag13
The token is in level13-1
Currently have no idea about why LD_PRELOAD=./libfake.so /home/flag13/flag13 doesn't work

TODO:LD_PRELOAD
	 ASM in linux http://asm.sourceforge.net/howto/dos.html
List of system call: http://asm.sourceforge.net/syscall.html
Test this in BT5R3
Test result:
No matter where target file is, the LD_PRELOAD=/tmp/libfake.so always work

Let's check the permission on target file
in BT5R3
result is in level13-2
in Nebula
result is in level13-3

A slightly different: -rwxr- Vs. -rwsr-
s: set user or group ID on execution
x: execution 

in BT5R3 change the permission of /Desktop/target and /tmp/target to -rwsr-, the result remains the same
in Nebula chmod u+s /tmp/flag13, the result remains the same

use gbd to disassemble /tmp/flag13 and /home/flag13/flag13 (in level13-4)
both of them will load libfake.so and return uid 1000 (They will jump to libfake.so only when we have run the assemble code once, otherwise they still do the following:
jmp *0x804a008 (0x804a008 falls in GOT
				use "readelf --relocs filename")

push $0x10
jmp  0x8048390
//see level13-5)
But the question is why it doesn't work when run from c code?

Clear the pre-loaded library and run /home/flag13/flag13 again then disassemble getuid:
see level13-6 for the result. (it uses the default lib)

use ldd to see the dynamically linked dependencies of /home/flag13/flag13 and /tmp/flag13
when libfake.so is pre-loaded, libfake.so is in the both of dependency lists. (Why )

another interesting solution:
http://www.pwntester.com/blog/2013/11/25/nebula-level13-write-up/

other refs:
http://stackoverflow.com/questions/5469274/what-does-plt-mean-here
http://t-a-w.blogspot.com/2007/03/modern-x86-assembly.html

https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html:
on the first call of a function, it falls through to call the default stub, which loads the identifier and calls into the dynamic linker, which at that point has enough information to figure out "hey, this libtest.so is trying to find the function foo". It will go ahead and find it, and then patch the address into the GOT such that the next time the original PLT entry is called, it will load the actual address of the function, rather than the lookup stub.
out of this indirection falls another handy thing â€” the ability to modify the symbol binding order. LD_PRELOAD, for example, simply tells the dynamic loader it should insert a library as first to be looked-up for symbols; therefore when the above binding happens if the preloaded library declares a foo, it will be chosen over any other one provided.

http://www.programlife.net/linux-got-plt.html
see level13-7 for the content in 0x0804a008 after the execution of getuid@plt (need to set a break point after the line of execution)
see level13-8 for the content in 0x0804a008 before the execution of getuid@plt

compare this to 
https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html:
http://www.programlife.net/linux-got-plt.html