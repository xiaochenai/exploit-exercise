In order to pass this challenge we need to fake our uid to 1000
http://www.linuxquestions.org/questions/programming-9/faking-uids-917910/
#include <stdio.h>

int main()
{
    int uid;

    __asm__ ("mov $24, %%eax;"
        "int $0x80;" //System calls in Linux are done through int 0x80.
        "movl %%eax, %0;"
        : "=r"(uid));
             
    printf("uid: %i\n", uid);
    return 0;
}

24. sys_getuid

Syntax: int sys_getuid(void)

Source: kernel/sys.c

Action: get user identity
This approach has not been got done yet.

http://mips42.altervista.org/ld_preload.php
create libfake.c libfake.so target.c target in /tmp
LD_PRELOAD=./libfake.so ./target works, the uid is 1000
LD_PRELOAD=./libfake.so /home/flag13/flag13 does not work
cp ./libfake.so /home/flag13/   permission denied
cp /home/flag13/flag13 ./       flag13 is copied to /tmp
LD_PRELOAD=./libfake.so ./flag13
The token is in level13-1
Currently have no idea about why LD_PRELOAD=./libfake.so /home/flag13/flag13 doesn't work

TODO:LD_PRELOAD
	 ASM in linux http://asm.sourceforge.net/howto/dos.html
List of system call: http://asm.sourceforge.net/syscall.html
Test this in BT5R3
Test result:
No matter where target file is, the LD_PRELOAD=/tmp/libfake.so always work

Let's check the permission on target file
in BT5R3
result is in level13-2
in Nebula
result is in level13-3

A slightly different: -rwxr- Vs. -rwsr-
s: set user or group ID on execution
x: execution 

in BT5R3 change the permission of /Desktop/target and /tmp/target to -rwsr-, the result remains the same
in Nebula chmod u+s /tmp/flag13, the result remains the same

use gbd to disassemble /tmp/flag13 and /home/flag13/flag13 (in level13-4)
both of them will jump to libfake.so and so they all work. (They will only jump to libfake.so only when we have run the assemble code once, otherwise they still do the following:
jmp *0x804a008
push $0x10
jmp  0x8048390
//see level13-5)
But the question is why it doesn't work when run from c code?
