getopt:http://man7.org/linux/man-pages/man3/getopt.3.html
setvbuf:http://man7.org/linux/man-pages/man3/setbuf.3.html
dprintf:http://unixhelp.ed.ac.uk/CGI/man-cgi?dprintf+3
setresgid:http://linux.die.net/man/2/setresgid
strchr: http://linux.die.net/man/3/strchr
strncmp: http://www.cplusplus.com/reference/cstring/strncmp/
In the while loop, 

If the user enters login*****
	then call login() with login username
If the user enters logout****
	then set globals.loggedin = 0
If the user enters shell*** and golbals.login is not 0 
	then execve("/bin/sh", argv, envp);//this looks helpful to us
If the user enters closelog××× and globals.debugfile is not 0
	then fclose(globals.debugfile
If the user enters site exec//first 9 characters
	then notsupported(line + 10)//the argument is the string starts from 10
If the user enters setuser//first 6 characters
	then setuser//starts from 8


The only place where set globals.login to 1 is in the login()，or we can use RE/debugging tools to find the address of globals.login and manually set it to 1, or use stack/heap/stack overflow to rewrite the memory of globals.login

use the function is looks the easist way. 

In login(), in order to set globals.login = 1 we need have line 26 fp = fopen(PWFILE, "r") return null

ref: http://blog.csdn.net/pizicai105/article/details/6128354
	 http://pubs.opengroup.org/onlinepubs/009695399/functions/fopen.html see the section of errors	

We can use one of the failure conditions in that section to make fopen() return null.
Refer to the references above, we can do something like that.
[EMFILE]
[CX] [Option Start] {OPEN_MAX} file descriptors are currently open in the calling process. [Option End]

use ulimit -a to print out the limitation info
notice the limit of the number of open file is 1024


"比如命令：ulimit -n  20规定了在当前bash环境下运行的程序只能同时打开20个fd，但是如果你做上面的测试程序，则只有17个。还有3个哪里去了？动脑筋想一下你应该能找到答案。"
http://en.wikipedia.org/wiki/File_descriptor
"There are three standard POSIX file descriptors"

Because in login() function there is no fclose() so once we opened a file the file descriptor would not be closed.

What we need to do is to consume 1021 file descriptors
1. in the while loop by calling login for 1021 times
2. open another file in the same bash for 1021 times

the screen shot of the result is in level18-1
then print "shell test" in the python script

"error while loading shared libraries: libncurses.so.5: cannot open shared object file: Error 24"

http://stackoverflow.com/questions/7876706/sh-error-while-loading-shared-libraries-libc-so-6-cannot-open-shared-object-f
http://www.virtsync.com/c-error-codes-include-errno
we need to closed one used file descriptor
1. use close() or fclose() or similar other functions
2. There is a fcloseed offered in line 109
3. 	http://stackoverflow.com/questions/5987820/how-to-close-file-descriptor-via-linux-shell-command
	http://unix.stackexchange.com/questions/131801/closing-a-file-descriptor-vs
	http://unix.stackexchange.com/questions/123413/close-all-file-descriptors-in-bash
	google "how to close a file descriptor" for more refs

add "closelog test" to print out and run again
some error info, add --help before -d /tmp/level18
still have some errors, ref: https://github.com/1u4nx/Exploit-Exercises-Nebula/blob/master/Level18%E2%80%94%E2%80%94%E8%B5%84%E6%BA%90%E6%9C%AA%E9%87%8A%E6%94%BE%E6%BC%8F%E6%B4%9E.md





